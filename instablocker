// ==UserScript==
// @name         Instagram Feed Uno-Reverse Filter (fetch/XHR interception)
// @namespace    local
// @version      2.1.0
// @description  Intercepts Instagram JSON responses and strips garbage accounts before the UI ever sees them.
// @match        https://www.instagram.com/*
// @run-at       document-start
// @grant        none
// ==/UserScript==

(() => {
  "use strict";

  /***********************************************************************
   *  READ THIS BEFORE YOU TOUCH ANYTHING.
   *
   *  This script intercepts Instagram’s network responses and surgically
   *  removes posts from accounts that match certain patterns.
   *
   *  If you do not understand:
   *    - fetch interception
   *    - XHR monkeypatching
   *    - recursive JSON mutation
   *
   *  Then DO NOT MODIFY THIS.
   *
   *  I am not responsible for what happens if you randomly delete
   *  something because you "thought it looked unnecessary".
   *
   *  You have been warned.
   ***********************************************************************/

  /**********************
   * SETTINGS
   **********************/

  // Accounts we absolutely do NOT touch.
  // If you remove yourself from this list and block yourself,
  // that’s between you and the universe.
  const EXCLUDED_USERNAMES = new Set(
    ["your_insta_handle_here"].map(s => s.toLowerCase())
  );

  // Patterns that trigger content deletion.
  // Yes, this is aggressive.
  // No, I do not care about your dropshipping hustle.
  const USERNAME_REGEXES = [
    // “official” nonsense
    /(^|[._-])official($|[._-])/i,
    /\bofficial\b/i,

    // Domain bait
    /\.com\b/i,
    /\.io\b/i,

    // Commerce sludge
    /\bmarket\b/i,
    /\bshop\b/i,
    /\bstore\b/i,
    /\boutlet\b/i,
    /\bboutique\b/i,
    /\bbrand\b/i,
    /\bpromo\b/i,
    /\bsales?\b/i,
    /\bdeals?\b/i,
    /\bdiscounts?\b/i,
    /\bwholesale\b/i,
    /\bmerch\b/i,
    /\bproducts?\b/i,

    // Corporate cosplay
    /\b(inc|llc|ltd|gmbh|co)\b/i,

    // Financial spam
    /\bcrypto\b/i,
    /\bnft\b/i,
    /\bforex\b/i,
    /\bbet(s|ting)?\b/i,
    /\bcasino\b/i,
    /\bloan(s)?\b/i,
    /\bfinance\b/i,
    /\binvest(ing|ment)?\b/i,

    // AI cop thirst trap industrial complex
    /\bpolice\b/i,
    /\bcop(s)?\b/i,
    /\bsheriff\b/i,
    /\bdeputy\b/i,
    /\btrooper\b/i,
    /\bpatrol\b/i,
    /\bbadge\b/i,
    /\blaw[_-]?enforcement\b/i,
    /\bthin\s*blue\s*line\b/i,
  ];

  // We don’t intercept literally everything,
  // because chaos has limits.
  const URL_ALLOWLIST = [
    "/graphql/query",
    "/api/",
    "/api/v1/",
  ];

  // Set to true if you want console logs explaining what’s being obliterated.
  const DEBUG = false;

  const log = (...args) => {
    if (DEBUG) console.log("[IG UnoReverse]", ...args);
  };

  function isExcluded(username) {
    return EXCLUDED_USERNAMES.has((username || "").toLowerCase());
  }

  function usernameMatches(username) {
    if (!username) return false;
    if (isExcluded(username)) return false;
    return USERNAME_REGEXES.some(rx => rx.test(username));
  }

  function shouldProcessUrl(url) {
    try {
      const u = new URL(url, location.href);
      return URL_ALLOWLIST.some(part => u.pathname.includes(part));
    } catch {
      return URL_ALLOWLIST.some(part => String(url).includes(part));
    }
  }

  /***********************************************************************
   * JSON SCRUBBER
   *
   * This walks the entire JSON response tree and removes anything owned
   * by a username that matches our patterns.
   *
   * Yes, recursively.
   * Yes, it’s invasive.
   * No, Instagram did not ask for consent.
   ***********************************************************************/
  function scrubJson(data) {
    const seen = new WeakSet();

    function getOwnerUsername(obj) {
      if (!obj || typeof obj !== "object") return null;

      if (typeof obj.username === "string") return obj.username;
      if (obj.user && typeof obj.user.username === "string") return obj.user.username;
      if (obj.owner && typeof obj.owner.username === "string") return obj.owner.username;
      if (obj.author && typeof obj.author.username === "string") return obj.author.username;

      return null;
    }

    function walk(node) {
      if (!node || typeof node !== "object") return node;
      if (seen.has(node)) return node;
      seen.add(node);

      if (Array.isArray(node)) {
        const out = [];
        for (const item of node) {
          const owner = getOwnerUsername(item);
          if (owner && usernameMatches(owner)) {
            log("Deleted content from:", owner);
            continue; // yeet
          }
          out.push(walk(item));
        }
        return out;
      }

      for (const k of Object.keys(node)) {
        node[k] = walk(node[k]);
      }

      const owner = getOwnerUsername(node);
      if (owner && usernameMatches(owner)) {
        log("Neutered object owned by:", owner);
        return null;
      }

      return node;
    }

    return walk(data);
  }

  /***********************************************************************
   * FETCH INTERCEPTION
   *
   * We override window.fetch BEFORE Instagram fully boots.
   * This is where the magic happens.
   *
   * If you don’t understand this section,
   * do not “optimize” it.
   ***********************************************************************/
  const realFetch = window.fetch;

  window.fetch = async function(input, init) {
    const url = typeof input === "string"
      ? input
      : (input && input.url) || "";

    if (!shouldProcessUrl(url)) {
      return realFetch.apply(this, arguments);
    }

    const resp = await realFetch.apply(this, arguments);

    const contentType = resp.headers.get("content-type") || "";
    if (!contentType.includes("application/json") &&
        !contentType.includes("text/javascript")) {
      return resp;
    }

    try {
      const cloned = resp.clone();
      const text = await cloned.text();

      let json;
      try {
        json = JSON.parse(text);
      } catch {
        return resp; // Not JSON? Not our problem.
      }

      const scrubbed = scrubJson(json);
      const newBody = JSON.stringify(scrubbed);

      log("Filtered response for:", url);

      return new Response(newBody, {
        status: resp.status,
        statusText: resp.statusText,
        headers: resp.headers,
      });

    } catch (e) {
      log("Filter error. Returning original response.", e);
      return resp;
    }
  };

  /***********************************************************************
   * XHR INTERCEPTION (Fallback)
   *
   * Because sometimes fetch isn’t enough.
   * And we do not trust Instagram to behave consistently.
   ***********************************************************************/
  const RealXHR = window.XMLHttpRequest;

  function PatchedXHR() {
    const xhr = new RealXHR();
    let requestUrl = "";

    const realOpen = xhr.open;
    xhr.open = function(method, url) {
      requestUrl = url || "";
      return realOpen.apply(this, arguments);
    };

    const realSend = xhr.send;
    xhr.send = function() {

      if (!shouldProcessUrl(requestUrl)) {
        return realSend.apply(this, arguments);
      }

      const origOnReady = xhr.onreadystatechange;

      xhr.onreadystatechange = function() {
        try {
          if (xhr.readyState === 4) {
            const ct = xhr.getResponseHeader("content-type") || "";
            if (ct.includes("application/json") ||
                ct.includes("text/javascript")) {

              let json;
              try {
                json = JSON.parse(xhr.responseText);
              } catch {}

              if (json) {
                const scrubbed = scrubJson(json);
                const newTxt = JSON.stringify(scrubbed);

                Object.defineProperty(xhr, "responseText", {
                  get: () => newTxt
                });
                Object.defineProperty(xhr, "response", {
                  get: () => newTxt
                });

                log("Filtered XHR response for:", requestUrl);
              }
            }
          }
        } catch (e) {
          log("XHR filter error:", e);
        }

        if (origOnReady) return origOnReady.apply(this, arguments);
      };

      return realSend.apply(this, arguments);
    };

    return xhr;
  }

  window.XMLHttpRequest = PatchedXHR;

  log("Uno Reverse loaded. Humanity remains disappointing.");
})();
